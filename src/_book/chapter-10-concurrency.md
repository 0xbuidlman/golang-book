---
title:  "Многопоточность"
layout: "chapter"

---

Очень часто, большие приложеня состоят из множества небольших под-программ. Например, web-сервер принимает запросы от браузера и отправляет HTML страницы в ответ. Каждый такой запрос выполняется как отдельная небольшая программа.

Такой способ идеально подходит для подобных приложений, так как обеспечивает возможность одновременного запуска множества более мелких компонентов (обработки нескольких запросов одновременно, в случае веб-сервера). Одновременное выполнение более чем одной задачи известно как многопоточность. Go имеет богатый функционал для работы с многпоточностью, в частности, такие инструменты как goroutines и channels.

## Goroutines

<!-- @TODO: Goroutines — как это по русски? -->

Goroutine — это функция, которая может работать параллельно с другими функциями. Для создания goroutine используется ключевое слово `go`, за которым следует вызов функции.

    package main

    import "fmt"

    func f(n int) {
        for i := 0; i < 10; i++ {
            fmt.Println(n, ":", i)
        }
    }

    func main() {
        go f(0)
        var input string
        fmt.Scanln(&input)
    }

Эта программа состоит из двух goroutine. Функция `main`, сама по себе, является goroutine. Вторая goroutine создаётся, когда мы вызываем `go f(0)`. Обычно, при вызове функции, программа выполнит все констукции внутри вызываемой функции, а только потом перейдет к, следующей после вызова, строке. С goroutine программа немедленно прейдет к следующей строке, не дожидаясь, пока вызываемая функция завершится. Вот почему здесь присуствует вызов `Scanln`, без него программа завершится еще перед тем, как ей удастся вывести числа.

Goroutines очень легкие, мы можем создавать их тысячами. Двайте изменим программу так, чтобы она запускала 10 goroutines:

    func main() {
        for i := 0; i < 10; i++ {
            go f(i)
        }
        var input string
        fmt.Scanln(&input)
    }

При запуске вы наверное заметили, что все goroutines выполняются последовательно, а не одновременно, как вы того ожидали. Давайте добавим небольшую задержку функции с помощью функции `time.Sleep` и `rand.Inin`:

    package main

    import (
        "fmt"
        "time"
        "math/rand"
    )

    func f(n int) {
        for i := 0; i < 10; i++ {
            fmt.Println(n, ":", i)
            amt := time.Duration(rand.Intn(250))
            time.Sleep(time.Millisecond * amt)
        }
    }
    func main() {
        for i := 0; i < 10; i++ {
            go f(i)
        }
        var input string
        fmt.Scanln(&input)
    }

`f` выводит числа от 0 до 10, ожидая от 0 до 250 мс после каждой операции вывода. Теперь goroutines должны выполняться одновременно.

## Каналы

Каналы обеспечивают возможность общения нескольких goroutines друг с другом, чтобы синхронизировать их выполнение. Вот пример программы с использованием каналов:

    package main

    import (
        "fmt"
        "time"
    )

    func pinger(c chan string) {
        for i := 0; ; i++ {
            c <- "ping"
        }
    }
    func printer(c chan string) {
        for {
            msg := <- c
            fmt.Println(msg)
            time.Sleep(time.Second * 1)
        }
    }
    func main() {
        var c chan string = make(chan string)
        
        go pinger(c)
        go printer(c)
        
        var input string
        fmt.Scanln(&input)
    }

Программа будет постоянно выводить «ping» (нажмите enter, чтобы её остановить). Тип канала представлен ключевым словом `chan`, за которым следует тип, который будет передаваться по каналу (в данном случае мы передаем строки). Оператор `<-` (стрелка влево) используется для отправки и получения сообщений по каналу. Конструкция `c <- "ping"` означает отправку `"ping"`, а `msg := <- c` — его получение и сохранение в переменную `msg`. Строка с `fmt` может быть записана другим способом: `fmt.Println(<-c)`, тогда можно было бы удалить предыдущую строку.
Данное использование каналов позволяет синхронизировать 2 goroutine'ы.
Когда `pinger` пытается послать сообщение в канал, он ожидает, пока `printer` будет готов получить сообщение.
Такое поведение называется блокирующим. Давайте добавим ещё одного отправителя сообщений в программу и посмотрим, что будет.
Добавим эту функцию:

    func ponger(c chan string) {
        for i := 0; ; i++ {
            c <- "pong"
        }
    }

и изменим функцию `main`:

    func main() {
        var c chan string = make(chan string)

        go pinger(c)
        go ponger(c)
        go printer(c)

        var input string
        fmt.Scanln(&input)
    }

Теперь программа будет выводить на экран то `ping`, то `pong` по очереди.

## Направление каналов

We can specify a direction on a channel type thus restricting it to either sending or receiving.
Мы может задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим.
Например, мы может изменить функцию `pinger`

    func pinger(c chan<- string)

и канал `c` будет только отправлять сообщение. Попытка получить сообщение из канала `c` вызовет ошибку компилирования.
Также мы может изменить функцию `printer`

    func printer(c <-chan string)

Существуют и двунаправленные каналы, которые могут переданны в функцию, принимающую только принимающие и отправляющие каналы.
Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!




