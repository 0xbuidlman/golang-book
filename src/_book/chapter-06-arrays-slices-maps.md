---
title:  "Массивы, срезы, отображения"
layout: "capter"

---

В главе 3 мы изучили базовые типы Go. В этой главе мы рассмотрим еще три встроеннх типа: массивы, срезы и отображения.

## Массивы

Массив это нумерованная последовательность элементов одного типа, с фиксированной длинной. В Go они выглядят так:

    var x [5]int

`x` это пример массива, состоящего из пяти элементов типа `intz. Запустим следующую програму:

    package main

    import "fmt"

    func main() {
        var x [5]int
        x[4] = 100
        fmt.Println(x)
    }

Вы должны увидеть следующее:

    [0 0 0 0 100]

`x[4] = 100` должно читаться как «присвоить пятому элементу массива x значение 100». Может показаться странным то, что `x[4]` это пятый элемент массива, а не четвертый но, как и строки, массивы нумеруются с нуля. Доступ к элементам массива выглядит так же, как у строк. Вместо `fmt.Println(x)` мы можем написать `fmt.Println(x[4])` и с результате будет напечатано `100`.

Пример программы, использующей массивы:

    func main() {
        var x [5]float64
        x[0] = 98
        x[1] = 93
        x[2] = 77
        x[3] = 82
        x[4] = 83
    
        var total float64 = 0
        for i := 0; i < 5; i++ {
            total += x[i]
        }
        fmt.Println(total / 5)
    }

Эта программы вычисляет седнюю оценку за экзамен. Если вы выполните её, то увидете `86.6`. Давайте рассмотрим её внимательней:

* Сперва мы создаем массив длины 5 и заполняем его.

* Затем, мы в цикле считаем общее количество баллов.

* И в конце мы делим общую сумму баллов на количество элементов, чтобы узнать средний балл.

Эта программа работает, но её всё еще можно улучшить. Во-первых, бросаются в глаза следующее: `i < 5` и `total / 5`. Если мы изменим количество оценок с 5 на 6, то придется переписывать код в этих двух местах. Будет лучше использовать длину массива:

    var total float64 = 0
    for i := 0; i < len(x); i++ {
        total += x[i]
    }
    fmt.Println(total / len(x))

Напишите этот кусок и запустите программу. Вы должны получить ошибку:

    $ go run tmp.go
    # command-line-arguments
    .\tmp.go:19: invalid operation: total / 5 (mismatched types float64 and int)

Проблема в том, что `len(x)` и `total` имеют разный тип. `total` имеет тип `float64`, а `len(x)` - `int`. Так что, нам надо конвертировать `len(x)` в `float64`:

    fmt.Println(total / float64(len(x)))


Это был пример преобразования типов. В общем, преобразование между типами выглядит так, что вы используете имя типа как функцию

Другая вещь, которую мы можем изменить в нашей програме это цикл:

    var total float64 = 0
    for i, value := range x {
        total += value
    }
    fmt.Println(total / float64(len(x)))

В этом цикле `i` представляет текущую позицию в массиве, а `value` будет тем же самым что и `x[i]`. Мы использовали ключевое слово `range` перед переменной, по которой мы хотим пройтись циклом.

Выполнение этой программы вызовет другую ошибку:

    $ go run tmp.go
    # command-line-arguments
    .\tmp.go:16: i declared and not used

Компилятор Go не позволяет вам создавать переменные, которые никогда не искользуются в коде. Поскольку мы не используем `i` внутри нашего цикла, то надо изменить код следующим образом:

    var total float64 = 0
    for _, value := range x {
        total += value
    }
    fmt.Println(total / float64(len(x)))

Одиночный символ полчеркивания `_` используется чтобы сказать компилятору, что нам не нужна переменная. (В данном случае нам не нужна переменная итератора)

А еще в Go есть короткая запись для создания массивов:

    x := [5]float64{ 98, 93, 77, 82, 83 }

Указывать тип не обязательно - Go сам может его выяснить, по содержимому массива.

Иногда массивы могут оказаться слишком длинными для записи в одну строку, в этом случае Go позволяет записывать их в несколько строк:

    x := [5]float64{ 
        98, 
        93, 
        77, 
        82, 
        83,
    }

Обратите мнимание на послднюю `,` после `83`. Она обязательна и позволяет легко удалить элемент из массива просто закомментировав строку:

    x := [4]float64{ 
        98, 
        93, 
        77, 
        82, 
        // 83,
    }

## Срезы

Срез это часть массива. Как и массивы срезы индексируются и имеют длину. В отличии от массивов, их длину можно изменить. Вот пример среза:

    var x []float64

Единственное отличие обявления сразе от обьявления массива - отсутствие длины между кавычек. В это случае `x` будет иметь длину 0.

Если вы хотите создать срез, то должны использовать вспроенную функцию `make`:

    x := make([]float64, 5)

Этот код создаст срез, который связан с массивом типа `float64` и длиной `5`. Среы всегда связаны с каким-нибудь массивом и хотя они не можуг стать больше чем массив, а вот меньше - пожалуйста. Функция `make` принимает и третий параметр:

    x := make([]float64, 5, 10)

`10` - это длина массива, на который указыввает срез:

![](/img/chapter-06/01.png)

Другой способ создать массив - оспользовать выражение `[low : high]`:

    arr := [5]float64{1,2,3,4,5}
    x := arr[0:5]

`low` это позиция, с которой будет начинаться срез, а `hign` это позиция до которой он будет (позиция `hign` НЕ включается!). Например: `arr[0:5]` вернет `[1,2,3,4,5]`, `arr[1:4]` вернет `[2,3,4]`.

Для удобства, мы также может опустить `low`, `high` или и то и другое.
`arr[0:]` это то же самое что `arr[0:len(arr)]`, `arr[:5]` то же самое что `arr[0:5] ` и `arr[:]` то же самое что `arr[0:len(arr)]`.

### Функции срезов

В Go есть две встроенные функции для срезов: `append` и `copy`. Вот пример работы функции `append':

func main() {
    slice1 := []int{1,2,3}
    slice2 := append(slice1, 4, 5)
    fmt.Println(slice1, slice2)
}

После выполнения программы `slice1` будет содержать `[1,2,3]`, а `slice2` - `[1,2,3,4,5]`. `append` создает новый срез из уже существующего (первый аргумент) и добавляет к нему все следующие аргументы.

Пример работы `copy`:

    func main() {
        slice1 := []int{1,2,3}
        slice2 := make([]int, 2)
        copy(slice2, slice1)
        fmt.Println(slice1, slice2)
    }

После выполнения этой программы `slice1` будет содержать `[1,2,3]`, а `slice2` - `[1,2]`. Содержимое `slice1` копируется в `slice2`, но поскольку в `slice2` есть место только для двух элементов, то только два первых элемента `slice1` будут скопировны.

##Отображения
Отображение (также известно как ассоциативный массив или словарь) это неупорядоченная коллекция пар вида ключ-значение. Пример:

    var x map[string]int
