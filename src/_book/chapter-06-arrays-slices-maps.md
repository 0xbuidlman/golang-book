---
title:  "Массивы, срезы, отображения"
layout: "chapter"

---

В главе 3 мы изучили базовые типы Go. В этой главе мы рассмотрим еще три встроеннх типа: массивы, срезы и отображения.

## Массивы

Массив это нумерованная последовательность элементов одного типа, с фиксированной длинной. В Go они выглядят так:

    var x [5]int

`x` это пример массива, состоящего из пяти элементов типа `intz. Запустим следующую програму:

    package main

    import "fmt"

    func main() {
        var x [5]int
        x[4] = 100
        fmt.Println(x)
    }

Вы должны увидеть следующее:

    [0 0 0 0 100]

`x[4] = 100` должно читаться как «присвоить пятому элементу массива x значение 100». Может показаться странным то, что `x[4]` это пятый элемент массива, а не четвертый но, как и строки, массивы нумеруются с нуля. Доступ к элементам массива выглядит так же, как у строк. Вместо `fmt.Println(x)` мы можем написать `fmt.Println(x[4])` и с результате будет напечатано `100`.

Пример программы, использующей массивы:

    func main() {
        var x [5]float64
        x[0] = 98
        x[1] = 93
        x[2] = 77
        x[3] = 82
        x[4] = 83
    
        var total float64 = 0
        for i := 0; i < 5; i++ {
            total += x[i]
        }
        fmt.Println(total / 5)
    }

Эта программы вычисляет седнюю оценку за экзамен. Если вы выполните её, то увидете `86.6`. Давайте рассмотрим её внимательней:

* Сперва мы создаем массив длины 5 и заполняем его.

* Затем, мы в цикле считаем общее количество баллов.

* И в конце мы делим общую сумму баллов на количество элементов, чтобы узнать средний балл.

Эта программа работает, но её всё еще можно улучшить. Во-первых, бросаются в глаза следующее: `i < 5` и `total / 5`. Если мы изменим количество оценок с 5 на 6, то придется переписывать код в этих двух местах. Будет лучше использовать длину массива:

    var total float64 = 0
    for i := 0; i < len(x); i++ {
        total += x[i]
    }
    fmt.Println(total / len(x))

Напишите этот кусок и запустите программу. Вы должны получить ошибку:

    $ go run tmp.go
    # command-line-arguments
    .\tmp.go:19: invalid operation: total / 5 (mismatched types float64 and int)

Проблема в том, что `len(x)` и `total` имеют разный тип. `total` имеет тип `float64`, а `len(x)` - `int`. Так что, нам надо конвертировать `len(x)` в `float64`:

    fmt.Println(total / float64(len(x)))


Это был пример преобразования типов. В общем, преобразование между типами выглядит так, что вы используете имя типа как функцию

Другая вещь, которую мы можем изменить в нашей програме это цикл:

    var total float64 = 0
    for i, value := range x {
        total += value
    }
    fmt.Println(total / float64(len(x)))

В этом цикле `i` представляет текущую позицию в массиве, а `value` будет тем же самым что и `x[i]`. Мы использовали ключевое слово `range` перед переменной, по которой мы хотим пройтись циклом.

Выполнение этой программы вызовет другую ошибку:

    $ go run tmp.go
    # command-line-arguments
    .\tmp.go:16: i declared and not used

Компилятор Go не позволяет вам создавать переменные, которые никогда не искользуются в коде. Поскольку мы не используем `i` внутри нашего цикла, то надо изменить код следующим образом:

    var total float64 = 0
    for _, value := range x {
        total += value
    }
    fmt.Println(total / float64(len(x)))

Одиночный символ полчеркивания `_` используется чтобы сказать компилятору, что нам не нужна переменная. (В данном случае нам не нужна переменная итератора)

А еще в Go есть короткая запись для создания массивов:

    x := [5]float64{ 98, 93, 77, 82, 83 }

Указывать тип не обязательно - Go сам может его выяснить, по содержимому массива.

Иногда массивы могут оказаться слишком длинными для записи в одну строку, в этом случае Go позволяет записывать их в несколько строк:

    x := [5]float64{ 
        98, 
        93, 
        77, 
        82, 
        83,
    }

Обратите мнимание на послднюю `,` после `83`. Она обязательна и позволяет легко удалить элемент из массива просто закомментировав строку:

    x := [4]float64{ 
        98, 
        93, 
        77, 
        82, 
        // 83,
    }

## Срезы

Срез это часть массива. Как и массивы срезы индексируются и имеют длину. В отличии от массивов, их длину можно изменить. Вот пример среза:

    var x []float64

Единственное отличие обявления сразе от обьявления массива - отсутствие длины между кавычек. В это случае `x` будет иметь длину 0.

Если вы хотите создать срез, то должны использовать вспроенную функцию `make`:

    x := make([]float64, 5)

Этот код создаст срез, который связан с массивом типа `float64` и длиной `5`. Среы всегда связаны с каким-нибудь массивом и хотя они не можуг стать больше чем массив, а вот меньше - пожалуйста. Функция `make` принимает и третий параметр:

    x := make([]float64, 5, 10)

`10` - это длина массива, на который указыввает срез:

![](/img/chapter-06/01.png)

Другой способ создать массив - оспользовать выражение `[low : high]`:

    arr := [5]float64{1,2,3,4,5}
    x := arr[0:5]

`low` это позиция, с которой будет начинаться срез, а `hign` это позиция до которой он будет (позиция `hign` НЕ включается!). Например: `arr[0:5]` вернет `[1,2,3,4,5]`, `arr[1:4]` вернет `[2,3,4]`.

Для удобства, мы также может опустить `low`, `high` или и то и другое.
`arr[0:]` это то же самое что `arr[0:len(arr)]`, `arr[:5]` то же самое что `arr[0:5] ` и `arr[:]` то же самое что `arr[0:len(arr)]`.

### Функции срезов

В Go есть две встроенные функции для срезов: `append` и `copy`. Вот пример работы функции `append':

func main() {
    slice1 := []int{1,2,3}
    slice2 := append(slice1, 4, 5)
    fmt.Println(slice1, slice2)
}

После выполнения программы `slice1` будет содержать `[1,2,3]`, а `slice2` - `[1,2,3,4,5]`. `append` создает новый срез из уже существующего (первый аргумент) и добавляет к нему все следующие аргументы.

Пример работы `copy`:

    func main() {
        slice1 := []int{1,2,3}
        slice2 := make([]int, 2)
        copy(slice2, slice1)
        fmt.Println(slice1, slice2)
    }

После выполнения этой программы `slice1` будет содержать `[1,2,3]`, а `slice2` - `[1,2]`. Содержимое `slice1` копируется в `slice2`, но поскольку в `slice2` есть место только для двух элементов, то только два первых элемента `slice1` будут скопировны.

## Отображения
Отображение (также известно как ассоциативный массив или словарь) это неупорядоченная коллекция пар вида ключ-значение. Пример:

    var x map[string]int

Отображение  представляется в эязке ключевым словом `map`, следующием за ним типом ключа в скобках и типом значения после скобок. Читается это следующим образом: «`x `это отбражение `string` в `int`».

Подобно массивам и срезам, к элементам отображения можно обратиться с помощью скобок. Запустим следующую программу:

    var x map[string]int
    x["key"] = 10
    fmt.Println(x)

Вы должны увидеть ошибку, похожую на эту:

    panic: runtime error: assignment to entry in nil map

    goroutine 1 [running]:
    main.main()
      main.go:7 +0x4d

    goroutine 2 [syscall]:
    created by runtime.main
            C:/Users/ADMINI~1/AppData/Local/Temp/2/bindi
    t269497170/go/src/pkg/runtime/proc.c:221
    exit status 2

До этого момента мы имели дело только с ошибками времени компиляции. В этом же случае мы имеем дело с ошибкой времени выполнения. Отличие в между ними в том, что ошибки времени выполнения происходят во время выполнения программы, а ошибки времени компиляции происходят во время компиляции программы.

Проблема нашей программы в том, что отображение должно быть инициализировнно передет тем, как будет использовано. Надо написать так:

    x := make(map[string]int)
    x["key"] = 10
    fmt.Println(x["key"])

Если вы выполните эту программу, то должны увидеть вывод `10`. Выражение `x["key"] = 10` похоже на те, что использовались при работе с массивами, но ключ тут не цисло, строка (потому что в отображении указан тип ключа `string`). Мы также можем создать отображение с ключем типа `int`:

    x := make(map[int]int)
    x[1] = 10
    fmt.Println(x[1])

Это выглядит очень похоже на мвссив, но существует несколько различий. Во-первых длина отображения (которую мы можем найти так: `len(x)`) может измениться, когда мы добавим новый элемент в него. В самом начале, при создании длина `0`, после `x[1] = 10` она станет равна `1`. Во-вторых, отображения не являются последовательностью. В нашем примере у нас есть элемент `x[1]`, в случае массива должен быть и первый элемент `x[0]`, но отображениях это не так,

Также, мы можем удалить элементы из отобрадения используя встроенную функцию `delete`:

    delete(x, 1)

Давайте посмотрим на пример программы, использующей отображения:

    package main

    import "fmt"

    func main() {
        elements := make(map[string]string)
        elements["H"] = "Hydrogen"
        elements["He"] = "Helium"
        elements["Li"] = "Lithium"
        elements["Be"] = "Beryllium"
        elements["B"] = "Boron"
        elements["C"] = "Carbon"
        elements["N"] = "Nitrogen"
        elements["O"] = "Oxygen"
        elements["F"] = "Fluorine"
        elements["Ne"] = "Neon"
    
        fmt.Println(elements["Li"])
    }

В данном примере, `elements` это отображение, которое представляет 10 первых химических элементов, индексируемых символоами. Это очень частый способ использования отображений - в качестве словаря, или таблицы. Предположим, мы пытаемся обратимся к не существующему элементу:

    fmt.Println(elements["Un"])

Если вы выполните это, то ничего не увидите. Технически, отображение вернет нулевое значение хранящегося типа (для строк это пустая строка). Несмотря на то, что мы можем проверить нулевое значение с помощью условия (`elements["Un"] == ""`), в Go есть лучший способ сделать это:

    name, ok := elements["Un"]
    fmt.Println(name, ok)

Доступ к элементу отображения может вернуть два значения вместо одного. Первое значение это результат запроса, второе говорит был ли запрос успешен. В Go часто встречается такой код:

    if name, ok := elements["Un"]; ok {    
        fmt.Println(name, ok)
    }

Сперва мы пробуем получить значение из отображения, а затем, если это удалось, мы выполняем код внутри блока.

Обьявления отображения можно записать скращенно, также как массивы:

    elements := map[string]string{
        "H": "Hydrogen",
        "He": "Helium",
        "Li": "Lithium",
        "Be": "Beryllium",
        "B": "Boron",
        "C": "Carbon",
        "N": "Nitrogen",
        "O": "Oxygen",
        "F": "Fluorine",
        "Ne": "Neon",
    }
Отображения часто используются для хранения общей информации. Давайте изменим нашу программу так, чтобы вместо имени элемента мы хранили кокую-ниюудь дополнительную информацию о нем. Например, его агрекатное состояние:

    func main() {
        elements := map[string]map[string]string{
                "H": map[string]string{
                "name":"Hydrogen", 
                "state":"gas",
            },
            "He": map[string]string{
                "name":"Helium", 
                "state":"gas",
            },
            "Li": map[string]string{
                "name":"Lithium", 
                "state":"solid",
            },
            "Be": map[string]string{
                "name":"Beryllium", 
                "state":"solid",
            },
            "B":  map[string]string{
                "name":"Boron",
                "state":"solid",
            },
            "C":  map[string]string{
                "name":"Carbon",
                "state":"solid",
            },
            "N":  map[string]string{
                "name":"Nitrogen",
                "state":"gas",
            },
            "O":  map[string]string{
                "name":"Oxygen",
                "state":"gas",
            },
            "F":  map[string]string{
                "name":"Fluorine",
                "state":"gas",
            },
            "Ne":  map[string]string{
                "name":"Neon",
                "state":"gas",
            },
        }

        if el, ok := elements["Li"]; ok {    
            fmt.Println(el["name"], el["state"])
        }
    }

Заметим, что тип нашего отображения теперь `map[string]map[string]string`. Теперь у нас отображение строк в отображение строк. Внешнее отображение испольщуется как поиск по символу химического элемента, а внутреннее - для хранения информации об элементе. Не смотря на то, что отображения часто используется таким образом, в главе 9 мы узнаем лучший способ хранения данных.

## Задачи

*  Как обратиться к четвертому элементу массива или среза?

*  Чему равна длина среза, созданного таким способом: `make([]int, 3, 9)`?

*  Дан массив:

        x := [6]string{"a","b","c","d","e","f"}

    что вернет вам `x[2:5]`?

*  Напишите программу, которая находит самый наименьший элемент в этом списке:

        x := []int{
            48,96,86,68,
            57,82,63,70,
            37,34,83,27,
            19,97, 9,17,
        }



